# Лабораторная работа №2

Необходимо спроектировать класс, реализующий хранение данных, связанных с экземпляром класса в динамической памяти. Это может быть, например представление целых чисел, для которых помимо значения типа `int` хранится строковое представление числа (22 и «двадцать два»). Пример условен. 

Для данного класса необходимо реализовать все необходимые конструкторы, включая конструкторы копирования и перемещения, деструктор. Все конструкторы и деструктор должны «сообщать» о своём вызове. `std::cout << “Copy constructor” << std::endl;` то же относится и к перегрузке операции присваивания (два варианта: без перемещения и с перемещением). 

Определение класса должно быть помещено в заголовочный файл (.hpp), реализация методов в отдельном файле .cpp.

Написать программу (ещё один модуль cpp) осуществляющую работу с экземплярами разработанного класса, которая должна демонстрировать:

* создание статических и динамических экземпляра класса, стандартного вектора в стиле Си, написать функцию для обработки данного вектора;
* передача экземпляров класса в функцию, и возврат экземпляра из функции; включая вариант с передачей и возвратом значений типа ссылки на класс;
* продемонстрировать работу с разработанным классом, создавая вектора и списки экземпляров класса, используя стандартные классы vector и list длиной от 5 до 10.

Проанализировать процессы создания и удаления экземпляров класса для различных примеров. Необходимо получить вывод от всех конструкторов, деструктора и перегруженных операций присваивания.

## Решение

Пример работы:

```
 % make compile
g++ generator.cpp -o generator
 % make run
Creating static object
Constructor called for value: -1
Value: -1, String Value: minus -1
Creating non-static object
Empty constructor called
Value: 0, String Value: 
Constructor called for value: 1
Value: 1, String Value: one
Constructor called for value: 2
Value: 2, String Value: two
Constructor called for value: 3
Constructor called for value: 4
Move constructor called for value: 3
Destructor called for value: 3
Value: 3, String Value: three
Value: 4, String Value: four
Constructor called for value: 5
Value: 5, String Value: five
Constructor called for value: 6
Constructor called for value: 7
Value: 6, String Value: sex
Value: 7, String Value: seven
Destructor called for value: 2
Destructor called for value: 6
Destructor called for value: 7
Destructor called for value: 5
Destructor called for value: 4
Destructor called for value: 3
Destructor called for value: 1
Destructor called for value: 0
Destructor called for value: -1
```

## Анализ

1. Создание статического объекта

```cpp
static MyNumber num_1{-1, "minus -1"};
```

Объект создается в статической области памяти и будет существовать на протяжении всего времени работы программы. Доступ к нему будет быстрым и не потребует дополнительной аллокации.

2. Создание объекта с конструктором по умолчанию

```cpp
MyNumber num0;
```

В данном случае объект создается на стеке. Производится вызов конструктора по умолчанию. Стековая аллокация в целом быстрее, но жизненный цикл объекта ограничен блоком, в котором он был создан.

3. Создание временного объекта

```cpp
MyNumber num1(1, "one");
```

Объект создается на стеке с заданными параметрами. Он будет уничтожен, когда выйдет из области видимости.

4. Динамическое создание объекта

```cpp
MyNumber* num2 = new MyNumber(2, "two");
```

Этот объект выделяется в динамической памяти с помощью оператора `new`. Он должен быть явно освобожден с помощью `delete`, чтобы избежать утечек памяти.

5. Работа с вектором

```cpp
std::vector<MyNumber> numVector;
numVector.emplace_back(3, "three");
numVector.emplace_back(4, "four");
processVector(numVector);
```

При вызове `emplace_back` объект MyNumber создается непосредственно в памяти вектора. Если вектор превышает выделенный размер, может произойти переалокация, что приведет к перемещению объектов и вызову их конструкторов копирования (или перемещения). Это также означает, что у объектов вектора будет время жизни, зависящее от вектора.

6. Создание временного объекта через функцию

```cpp
MyNumber num3 = createMyNumber(5, "five");
```

`createMyNumber` создает объект `MyNumber` и возвращает его. Здесь может использоваться оптимизация возврата (RVO – Return Value Optimization), которая позволяет избежать лишней копии.

7. Работа со списком

```cpp
std::list<MyNumber> numList;
numList.emplace_back(6, "sex");
numList.emplace_back(7, "seven");
```

Похожим образом, в элементы `std::list` добавляются объекты `MyNumber`. Списки в C++ используют динамическое выделение под каждый элемент и требуют больше накладных расходов, но позволяют более гибкое управление памятью.

8. Освобождение динамически выделенной памяти

```cpp
delete num2;
```

Раздел `delete` завершает жизненный цикл объекта `MyNumber`, выделенного ранее динамически, что предотвращает утечку памяти.

## Выводы

* Стековая аллокация является более эффективной и быстрой, но ограничивает время жизни объектов. Они автоматически освобождаются по выходу из своей области видимости.
* Динамическая аллокация предоставляет более гибкие возможности, так как позволяет создавать объекты, время жизни которых не привязано к области видимости, но требует ручного управления памятью и может привести к утечкам, если не будет освобождена.
* Использование `std::vector` и `std::list` требует дополнительных затрат на управление памятью (как по выделению, так и по перемещению при изменении размера). Векторы обеспечивают сравнительно более быстрые операции добавления и доступа, но могут производить дополнительные копии при изменении размера.
